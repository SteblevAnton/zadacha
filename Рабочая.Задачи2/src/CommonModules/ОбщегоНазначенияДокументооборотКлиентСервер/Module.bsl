////////////////////////////////////////////////////////////////////////////////
// Общего назначения документооборот клиент сервер:
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Удаляет из массив вытесняемое значение, при наличии в массиве вытесняющего значения.
//
// Параметры:
//  ОбрабатываемыйМассив - Массив       - Массив, из которого происходит вытеснение.
//  ВытесняющееЗначение  - Произвольный - Значение, наличие которого приводит к вытеснению.
//  ВытесняемоеЗначение  - Произвольный - Значение, вытеснение которого производится.
//
Процедура ВытеснитьИзМассива(ОбрабатываемыйМассив, ВытесняющееЗначение, ВытесняемоеЗначение) Экспорт
	
	ИндексВытесняющегоЗначения = ОбрабатываемыйМассив.Найти(ВытесняющееЗначение);
	
	// Вытесняющего значения нет в обрабатываемом массиве - вытеснение не требуется.
	Если ИндексВытесняющегоЗначения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Удалим все вытесняемые значения в массиве.
	ИндексВытесняемогоЗначения = ОбрабатываемыйМассив.Найти(ВытесняемоеЗначение);
	Пока ИндексВытесняемогоЗначения <> Неопределено Цикл
		ОбрабатываемыйМассив.Удалить(ИндексВытесняемогоЗначения);
		ИндексВытесняемогоЗначения = ОбрабатываемыйМассив.Найти(ВытесняемоеЗначение);
	КонецЦикла;
	
КонецПроцедуры

// Формирует пересечение массивов.
//
// Параметры:
//  Массив1 - Массив.
//  Массив2 - Массив.
// 
// Возвращаемое значение:
//  Массив - Пересечение массив. 
//
Функция ПересечениеМассивов(Массив1, Массив2) Экспорт
	
	ПересечениеМассивов = Новый Массив;
	
	Для Каждого Элемент Из Массив2 Цикл
		
		Индекс = Массив1.Найти(Элемент);
		Если Индекс <> Неопределено Тогда
			ПересечениеМассивов.Добавить(Элемент);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПересечениеМассивов;
	
КонецФункции

// Возвращает текстовое представление единицы измерения в правильном склонении и числе
//
// Параметры
//  Число - Число - любое целое число.
//	ПараметрыПредметаИсчисления - Строка - варианты написания единицы измерения в родительном
//										   падеже для одной, для двух и для пяти единиц, разделитель
//										   - запятая. Пример: "минуту,минуты,минут".
//
// Возвращаемое значение
//  Строка - текстовое представление единицы измерения.
//
Функция ПредметИсчисленияПрописью(Знач Число, Знач ПараметрыПредметаИсчисления) Экспорт

	Результат = "";
	
	МассивПредставлений = Новый Массив;
	
	Позиция = Найти(ПараметрыПредметаИсчисления, ",");
	Пока Позиция > 0 Цикл
		Значение = СокрЛП(Лев(ПараметрыПредметаИсчисления, Позиция-1));
		ПараметрыПредметаИсчисления = Сред(ПараметрыПредметаИсчисления, Позиция + 1);
		МассивПредставлений.Добавить(Значение);
		Позиция = Найти(ПараметрыПредметаИсчисления, ",");
	КонецЦикла;
	
	Если СтрДлина(ПараметрыПредметаИсчисления) > 0 Тогда
		Значение = СокрЛП(ПараметрыПредметаИсчисления);
		МассивПредставлений.Добавить(Значение);
	КонецЕсли;	
	
	Если Число >= 100 Тогда
		Число = Число - Цел(Число / 100)*100;
	КонецЕсли;
	
	Если Число > 20 Тогда
		Число = Число - Цел(Число/10)*10;
	КонецЕсли;
	
	Если Число = 1 Тогда
		Результат = МассивПредставлений[0];
	ИначеЕсли Число > 1 И Число < 5 Тогда
		Результат = МассивПредставлений[1];
	Иначе
		Результат = МассивПредставлений[2];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Разделяет переданный массив на нескольков массивов указанного размера.
// Если размер части меньше 1, то будет вызвано исключение.
//
// Параметры:
//  РазделяемыйМассив - Массив - Массив, который следует разделить.
//  РазмерЧасти - Число - Размер части, на которую следует разделить массив.
// 
// Возвращаемое значение:
//  Массив - Разделенные массивы.
//
Функция РазделитьМассив(РазделяемыйМассив, РазмерЧасти) Экспорт
	
	Если РазмерЧасти < 1 Тогда
		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Некорректный размер части массива для разеления: %1'"),
			Формат(РазмерЧасти, "ЧН=0; ЧГ="));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	РазделенныеМассивы = Новый Массив;
	
	МассивТекущейЧасти = Новый Массив;
	Для Каждого ЭлементМассив Из РазделяемыйМассив Цикл
		
		МассивТекущейЧасти.Добавить(ЭлементМассив);
		
		Если МассивТекущейЧасти.Количество() >= РазмерЧасти Тогда
			РазделенныеМассивы.Добавить(МассивТекущейЧасти);
			МассивТекущейЧасти = Новый Массив;
		КонецЕсли;
		
	КонецЦикла;
	
	Если МассивТекущейЧасти.Количество() > 0 Тогда
		РазделенныеМассивы.Добавить(МассивТекущейЧасти);
	КонецЕсли;
	
	Возврат РазделенныеМассивы;
	
КонецФункции

// Возвращает случайное число из указанного диапазона
// Параметры:
//  Минимум - Число - начало диапазона
//  Максимум - Число - конец диапазона
//  СчетчикГСЧ - Число - числовая переменная, которая сохраняет свое значение
//   между вызовами функции в случае, если интервал между вызовами небольшой (0-1 мс)
//  ВспомогательныйВызов - Булево - служебный параметр, заполнять не нужно
//  
Функция СлучайноеЧислоБезИспользованияГенератора(
		Минимум, Максимум, СчетчикГСЧ = 0, ВспомогательныйВызов = Ложь) Экспорт
	
	Результат = Минимум;
	
	Если Минимум < Максимум Тогда
		
		Делитель = 1;
		Если Не ВспомогательныйВызов Тогда
			Делители = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("2,3,5,7,11");
			Делитель = Делители[СлучайноеЧислоБезИспользованияГенератора(0, 4, СчетчикГСЧ, Истина)];
		КонецЕсли;
		
		Результат = Цел((ТекущаяУниверсальнаяДатаВМиллисекундах() + СчетчикГСЧ) / Делитель) % Максимум;
		
		Если Результат < Минимум Тогда
			Шаг = (Максимум - Минимум + 1);
			Результат = Результат + Шаг * Цел((Максимум - Результат) / Шаг);
		КонецЕсли;
		
	КонецЕсли;
	
	СчетчикГСЧ = СчетчикГСЧ + 13;
	
	Возврат Результат;
	
КонецФункции

// Сортирует переданный массив.
//
// Параметры:
//  МассивДляСортировки   - Массив                - Массив для сортировки.
//  НаправлениеСортировки - НаправлениеСортировки - Направление сортировки. Значение по умолчанию: Возр.
//
// Возвращаемое значение:
//  Массив - Отсортированный массив.
//
Функция СортироватьМассив(МассивДляСортировки, НаправлениеСортировки = Неопределено) Экспорт
	
	СписокДляСортировки = Новый СписокЗначений;
	СписокДляСортировки.ЗагрузитьЗначения(МассивДляСортировки);
	СписокДляСортировки.СортироватьПоЗначению(НаправлениеСортировки);
	ОтсортированныйМассив = СписокДляСортировки.ВыгрузитьЗначения();
	
	Возврат ОтсортированныйМассив;
	
КонецФункции

// Показывает/скрывает кнопку очистки, если значение отбора заполнено/не заполнено.
//
// Параметры:
//   Поле     - ПолеФормы - элемент формы, в котором будет включена/выключена кнопка очистки.
//   Значение - ЛюбаяСсылка - значение отбора.
//   ЗначениеПоУмолчанию - ЛюбаяСсылка - значение по умолчанию, на которое не нужно накладывать оформление.
//
Процедура ПоказатьСкрытьКнопкуОчисткиОтбора(Поле, Значение, ЗначениеПоУмолчанию = "") Экспорт
	
	Если ТипЗнч(Поле) <> Тип("ПолеФормы") Тогда 
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Значение) Тогда 
		Если Не ЗначениеЗаполнено(ЗначениеПоУмолчанию)
			Или (ЗначениеЗаполнено(ЗначениеПоУмолчанию) И Значение <> ЗначениеПоУмолчанию) Тогда 
			Поле.КнопкаОчистки = Истина;
			#Если Клиент Тогда
				Поле.ЦветФона = ОбщегоНазначенияКлиент.ЦветСтиля("ФонУправляющегоПоля");
			#Иначе
				Поле.ЦветФона = ЦветаСтиля["ФонУправляющегоПоля"];
			#КонецЕсли
		Иначе 
			Поле.КнопкаОчистки = Ложь;
			Поле.ЦветФона = Новый Цвет();
		КонецЕсли;
	Иначе 
		Поле.КнопкаОчистки = Ложь;
		Поле.ЦветФона = Новый Цвет();
	КонецЕсли;
	
КонецПроцедуры

// Выделяет из имени файла его имя (набор символов до последней точки).
//
// Параметры:
//  ИмяФайла - Строка - имя файла с именем каталога или без.
//
// Возвращаемое значение:
//   Строка - имя файла.
//
Функция ПолучитьТолькоИмяИмениФайла(Знач ИмяФайла) Экспорт
	
	ТолькоИмя = "";
	
	ПозицияСимвола = СтрДлина(ИмяФайла);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияСимвола, 1) = "." Тогда
			
			ТолькоИмя = Лев(ИмяФайла, ПозицияСимвола - 1);
			Прервать;
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;
	КонецЦикла;

	Возврат ТолькоИмя;
	
КонецФункции

// Возвращает тип объекта. Если тип объекта неизвестен, то вызывает исключение.
// 
// Параметры:
//  ТипЗначения - Тип, ЛюбаяСсылка.
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.ТипыОбъектов - Тип объекта.
//  
Функция ТипОбъекта(ТипИлиСсылка) Экспорт
	
	Если ТипЗнч(ТипИлиСсылка) = Тип("Тип") Тогда
		Тип = ТипИлиСсылка
	Иначе
		Тип = ТипЗнч(ТипИлиСсылка);
	КонецЕсли;
	
	Если Тип = Тип("СправочникСсылка.ДокументыПредприятия") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.ДокументыПредприятия");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Контрагенты") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Контрагенты");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Мероприятия") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Мероприятия");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Пользователи") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Пользователи");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.ПроектныеЗадачи") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.ПроектныеЗадачи");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Проекты") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Проекты");
		
	ИначеЕсли Тип = Тип("СправочникСсылка.Файлы") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Файлы");
		
	Иначе
		
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неизвестен тип объекта для типа %1.'"),
			Тип);
		
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Возвращает тип объекта по виду объекта. Если тип объекта неизвестен, то вызывает исключение.
// 
// Параметры:
//  ТипИлиСсылкаВидаОбъекта - Тип, ЛюбаяСсылка.
// 
// Возвращаемое значение:
//  ПеречислениеСсылка.ТипыОбъектов - Тип объекта.
//  
Функция ТипОбъектаПоТипуВидаОбъекта(ТипИлиСсылкаВидаОбъекта) Экспорт
	
	Если ТипЗнч(ТипИлиСсылкаВидаОбъекта) = Тип("Тип") Тогда
		ТипВидаОбъекта = ТипИлиСсылкаВидаОбъекта
	Иначе
		ТипВидаОбъекта = ТипЗнч(ТипИлиСсылкаВидаОбъекта);
	КонецЕсли;
	
	Если ТипВидаОбъекта = Тип("СправочникСсылка.ВидыДокументов") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.ДокументыПредприятия");
		
	ИначеЕсли ТипВидаОбъекта = Тип("СправочникСсылка.ВидыМероприятий") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Мероприятия");
		
	ИначеЕсли ТипВидаОбъекта = Тип("СправочникСсылка.ВидыПроектов") Тогда
		
		ТипОбъекта = ПредопределенноеЗначение("Перечисление.ТипыОбъектов.Проекты");
		
	Иначе
		
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неизвестен тип объекта для типа вида объекта %1.'"),
			ТипВидаОбъекта);
		
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Устанавливает или отключает быстрый отбор списка,
// выполняет все необходимые действия с элементом формы, отображающим значение быстрого отбора.
// 
// Параметры:
//   Список - ДинамическийСписок - Список, в котором требуется изменить отбор.
//   ИмяПоляСписка - Строка - Поле, по которому необходимо изменить отбор.
//   ЗначениеОтбора - Произвольный - Значение отбора.
//   ПолеОтбора - ЭлементФормы - элемент формы, который отображает значение отбора.
// 
Процедура ИзменитьБыстрыйОтборСписка(Список, ИмяПоляСписка, ЗначениеОтбора, ПолеОтбора) Экспорт
	
	Если ЗначениеЗаполнено(ЗначениеОтбора) Тогда
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
		ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
			Список, ИмяПоляСписка, ЗначениеОтбора,,, Истина,
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный);
	Иначе
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
	КонецЕсли;
	
	ПоказатьСкрытьКнопкуОчисткиОтбора(ПолеОтбора, ЗначениеОтбора);
	
КонецПроцедуры

// Устанавливает отбор списка.
//
// Параметры:
//  Список - ДинамическийСписок - Список, для которого нужно установить отбор.
//  ИмяПараметра - Строка - Имя параметра списка.
//  ЗначениеОтбора - Произвольный - Значение отбора.
//  ПолеОтбора - ПолеФормы - Элемент формы, соответсвующий отбору.
//
Процедура УстановитьОтборСписка(Список, ИмяПараметра, ЗначениеОтбора, ПолеОтбора) Экспорт
	
	Параметр = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Параметр.Использование = Ложь;
	Если ЗначениеЗаполнено(ЗначениеОтбора) Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, ЗначениеОтбора);
	КонецЕсли;
	
	ПоказатьСкрытьКнопкуОчисткиОтбора(ПолеОтбора, ЗначениеОтбора);
	
КонецПроцедуры

// Устанавливает отбор показа удаленных.
//
// Параметры:
//  Список - ДинамическийСписок - Список, для которого нужно установить отбор.
//  ПоказыватьУдаленные - Булево - Параметр показывать удаленные.
//  Команда - КомандаФормы - Команда "Показывать удаленные".
//
Процедура УстановитьОтборПоказыватьУдаленные(Список, ПоказыватьУдаленные, Команда) Экспорт
	
	ИмяПоляСписка = "ПометкаУдаления";
	Если ПоказыватьУдаленные Тогда
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбораДинамическогоСписка(Список, ИмяПоляСписка);
	Иначе
		ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
			Список,
			ИмяПоляСписка,
			Ложь,,,
			Истина,
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный);
	КонецЕсли;
	
	Команда.Пометка = ПоказыватьУдаленные;
	
КонецПроцедуры

// Определяет, есть ли какие-то отличия в таблицах, выполняя поэлементное сравнение.
// 
// Параметры:
//  Таблица1 - Коллекция.
//  Таблица2 - Коллекция.
//  ПоляДляСравнения - Строка - список полей, разделенных запятыми.
// 
// Возвращаемое значение:
//  Булево - признак того, что коллекции отличаются.
//
Функция ЕстьОтличияВТаблицах(Таблица1, Таблица2, ПоляДляСравнения) Экспорт
	
	КоличествоЗаписей = Таблица1.Количество();
	ЕстьОтличия = КоличествоЗаписей <> Таблица2.Количество();
	
	Если Не ЕстьОтличия Тогда
		
		ПоляДляСравнения = СтрРазделить(ПоляДляСравнения, ",");
		Для Сч = 0 По КоличествоЗаписей - 1 Цикл
			Для Каждого Эл Из ПоляДляСравнения Цикл
				ИмяПоля = СокрЛП(Эл);
				Если Таблица1[Сч][ИмяПоля] <> Таблица2[Сч][ИмяПоля] Тогда
					Возврат Истина;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ЕстьОтличия;
 	
КонецФункции

// Определяет, есть ли какие-то отличия в массива, выполняя поэлементное сравнение.
// 
// Параметры:
//  Массив1 - Коллекция.
//  Массив2 - Коллекция.
// 
// Возвращаемое значение:
//  Булево - признак того, что коллекции отличаются.
//
Функция ЕстьОтличияВМассивах(Массив1, Массив2) Экспорт
	
	КоличествоЗаписей = Массив1.Количество();
	ЕстьОтличия = КоличествоЗаписей <> Массив2.Количество();
	
	Если Не ЕстьОтличия Тогда
		
		Для Сч = 0 По КоличествоЗаписей - 1 Цикл
			Если Массив1[Сч] <> Массив2[Сч] Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ЕстьОтличия;
 	
КонецФункции

// Выгружает значения соответствия.
//
// Параметры:
//  Соответствие - Соответствие - Соответствие.
// 
// Возвращаемое значение:
//  Массив - Значения соответствия.
//
Функция ЗначенияСоответствия(Соответствие) Экспорт
	
	ЗначенияСоответствия = Новый Массив;
	Для Каждого КлючИЗначение Из Соответствие Цикл
		ЗначенияСоответствия.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат ЗначенияСоответствия;
	
КонецФункции

// Распределяет массив в соответствие по типам.
//
// Параметры:
//  ОбарабатываемыйМассив - Массив - Обарабатываемый массив
// 
// Возвращаемое значение:
//  Соответствие - Массив, распределенный по типам.
//   Ключ - Тип - Тип значения массив.
//   Значение - Массив - Значения массива указанного типа.
//
Функция СоответствиеПоТипам(ОбарабатываемыйМассив) Экспорт
	
	СоответствиеПоТипам = Новый Соответствие;
	Для Каждого ЭлементМассива Из ОбарабатываемыйМассив Цикл
		
		ТипЭлементаМассива = ТипЗнч(ЭлементМассива);
		
		МассивТипа = СоответствиеПоТипам[ТипЭлементаМассива];
		Если МассивТипа = Неопределено Тогда
			СоответствиеПоТипам.Вставить(ТипЭлементаМассива, Новый Массив);
			МассивТипа = СоответствиеПоТипам[ТипЭлементаМассива];
		КонецЕсли;
		МассивТипа.Добавить(ЭлементМассива);
		
	КонецЦикла;
	
	Возврат СоответствиеПоТипам;
	
КонецФункции

// Возвращает текст о необходимости записи данных.
//
// Параметры:
//  НазваниеКоманды - Строка - название выполняемой команды.
// 
// Возвращаемое значение:
//  Строка - Текст о необходимости записи данных.
//
Функция ТекстВопросаНезаписанныхДанных(НазваниеКоманды) Экспорт 
	
	Возврат СтрШаблон(
		НСтр("ru = 'Данные еще не записаны.
              |Выполнение действия ""%1"" возможно только после записи данных.
              |Данные будут записаны.'"),
		НазваниеКоманды);
	
КонецФункции

#Область РаботаСДеревом

// Выполняет переданный код для всех строк дерева или его ветки.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент.
//  Код - Строка - код, который нужно выполнить для каждой строки дерева или его ветки.
//      В коде могут использовать переменные: 
//      ТекущаяСтрока - для работы с текущей строкой дерева.
//      ПрерватьОбработку - для установки признака прерывания цикла.
//                                        
//  ДопПараметры - Структура, Неопределено - дополнительные параметры, которые могут использоваться в коде.
//
Процедура ВыполнитьДействиеДляВсехСтрокДерева(Ветка, Код, ДопПараметры = Неопределено) Экспорт
	
	СтрокиКОбработке = Новый Массив;
	Для Каждого Строка Из Ветка.ПолучитьЭлементы() Цикл
		СтрокиКОбработке.Добавить(Строка);
	КонецЦикла;
	
	ПрерватьОбработку = Ложь;
	Пока СтрокиКОбработке.Количество() > 0 И Не ПрерватьОбработку Цикл
		
		ТекущаяСтрока = СтрокиКОбработке[0];
		СтрокиКОбработке.Удалить(0);
		
		Выполнить(Код);
		
		Для Каждого Строка Из ТекущаяСтрока.ПолучитьЭлементы() Цикл
			СтрокиКОбработке.Добавить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет поиск строк дерева в соответствии с переданным отбором.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент, 
//          в рамках которых выполняется поиск.
//  СтруктураОтбора - Структура - структура, по значениям которой будет выполняться поиск.
//
// Возвращаемое значение:
//   Массив - массив найденных строк.
//
Функция НайтиСтрокиДерева(Ветка, СтруктураОтбора) Экспорт
	
	Возврат НайтиСтрокиВеткиДереваПоОтбору(Ветка, СтруктураОтбора, Ложь);
	
КонецФункции

// Выполняет поиск первой строки дерева в соответствии с переданным отбором.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент, 
//          в рамках которых выполняется поиск.
//  СтруктураОтбора - Структура - структура, по значениям которой будет выполняться поиск.
//
// Возвращаемое значение:
//   ДанныеФормыЭлементДерева - найденная строка.
//
Функция НайтиСтрокуДерева(Ветка, СтруктураОтбора) Экспорт
	
	Результат = Неопределено;
	
	НайденныеСтроки = НайтиСтрокиВеткиДереваПоОтбору(Ветка, СтруктураОтбора, Истина);
	Если НайденныеСтроки.Количество() > 0 Тогда
		Результат = НайденныеСтроки[0];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив всех строк дерева или его ветки.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент,
//    строки которого нужно получить.
//
// Возвращаемое значение:
//   Массив - массив строк дерева.
//
Функция ВсеСтрокиДерева(Ветка) Экспорт
	
	Результат = Новый Массив;
	
	ДопПараметры = Новый Структура("Результат", Результат);
	ВыполняемыйКод = "ДопПараметры.Результат.Добавить(ТекущаяСтрока)";
	ВыполнитьДействиеДляВсехСтрокДерева(Ветка, ВыполняемыйКод, ДопПараметры);
	
	Возврат Результат;
	
КонецФункции

// Заполняет колонки всех строк дерева или его ветки переданными значениями.
//
// Параметры:
//  Ветка - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент.
//  ЗначенияДляЗаполнения - Структура - значения, которыми нужно заполнить колонки дерева.
//
Процедура ЗаполнитьКолонкиДерева(Ветка, ЗначенияДляЗаполнения) Экспорт
	
	ДопПараметры = Новый Структура("ЗначенияДляЗаполнения", ЗначенияДляЗаполнения);
	ВыполняемыйКод = "ЗаполнитьЗначенияСвойств(ТекущаяСтрока, ДопПараметры.ЗначенияДляЗаполнения)";
	ВыполнитьДействиеДляВсехСтрокДерева(Ветка, ВыполняемыйКод, ДопПараметры);
	
КонецПроцедуры

#КонецОбласти

// Возвращает копию массива, не обходя его элементы рекурсивно, в отличие от
// ОбщегоНазначенияКлиентСервер.СкопироватьМассив().
// Поэтому функцию следует использовать для копирования массивов без слоных вложенных конструкций
// (вложенные массивы, таблицы значений, соотвествия, струкутры, списки значений и т.д.).
//
// Параметры:
//   Массив - Массив - копируемый массив.
//
// Возвращаемое значение:
//   Массив - копия исходного массива.
//
Функция ПростаяКопияМассива(Массив) Экспорт
	
	Копия = Новый Массив;
	Для Каждого Элемент Из Массив Цикл
		Копия.Добавить(Элемент);
	КонецЦикла;
	
	Возврат Копия;
	
КонецФункции

// Возвращает пустой уникальный идентификатор - тот, который соответствует пустой ссылке.
// 
Функция ПустойУникальныйИдентификатор() Экспорт
	
	Возврат Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	
КонецФункции

// Маскирует спецсимволы в тексте для его использования в оператора запроса ПОДОБНО,
// чтобы текст использовался как есть.
// Символы "%", "~", "_", "[", "]", "^", "/" в исходной строке предваряются символом маскировки.
//
// Параметры:
//  Текст - Строка
//  СимволМаскировки - Строка - строка с одним символом.
//
// Возвращаемое значение:
//  Строка - измененная строка
//
Функция ЗамаскироватьСпецсимволыДляОператораЗапросаПОДОБНО(Текст, СимволМаскировки = "/") Экспорт
	
	Строки = СтрРазделить(Текст, "%~_[]^/", Истина);
	
	Если Строки.Количество() > 1 Тогда
		Дл = СтрДлина(Строки[0]) + 1;
		Для Ин = 1 По Строки.ВГраница() Цикл
			Строки[Ин] = Сред(Текст, Дл, 1) + Строки[Ин];
			Дл = Дл + СтрДлина(Строки[Ин]);
		КонецЦикла;
		Возврат СтрСоединить(Строки, СимволМаскировки);
		
	Иначе
		Возврат Текст;
		
	КонецЕсли;
	
КонецФункции

// Копирует строку в другое дерево или в другую ветку дерева вместе с подстроками.
//
// Параметры:
//  СтрокаДерева - СтрокаДереваЗначений - строка, которую нужно скопировать.
//  ВеткаПриемник - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево или его элемент,
//		куда будет добавлена скопированная строка.
//
Процедура СкопироватьСтрокуДерева(СтрокаДерева, ВеткаПриемник) Экспорт
	
	ПарыСтрокКОбработке = Новый Массив;
	ПарыСтрокКОбработке.Добавить(Новый Структура("Источник, Приемник",
		СтрокаДерева, ВеткаПриемник.ПолучитьЭлементы().Добавить()));
	
	Пока ПарыСтрокКОбработке.Количество() > 0 Цикл
		
		Источник = ПарыСтрокКОбработке[0].Источник;
		Приемник = ПарыСтрокКОбработке[0].Приемник;
		ПарыСтрокКОбработке.Удалить(0);
		
		ЗаполнитьЗначенияСвойств(Приемник, Источник);
		
		Для Каждого ПодчиненнаяСтрока Из Источник.Строки Цикл
			ПарыСтрокКОбработке.Добавить(Новый Структура("Источник, Приемник",
				ПодчиненнаяСтрока, Приемник.ПолучитьЭлементы().Добавить()));
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает представление по строковому наименованию переменной, объекта, параметра и т.д.
// 
// Например, для строки "ОбщегоНазначенияДокументооборотКлиентСервер" будет возвращено представление
// "Общего назначения документооборот клиент сервер".
// 
// Параметры:
//  Наименование - Строка
// 
// Возвращаемое значение:
//  Строка
//  
Функция ПредставлениеПоНаименованию(Наименование) Экспорт
	
	Наименование_ВР = ВРег(Наименование);
	
	Если Наименование = Наименование_ВР Тогда
		Возврат Наименование;
	КонецЕсли; 
	
	Результат = Новый Массив;
	
	Для НомерСимвола = 1 По СтрДлина(Наименование) Цикл
					
		Если НомерСимвола = 1 Тогда
			
			Результат.Добавить(Сред(Наименование, НомерСимвола, 1));
		
		ИначеЕсли КодСимвола(Наименование, НомерСимвола) = 
			КодСимвола(Наименование_ВР, НомерСимвола) Тогда
			 
			Результат.Добавить(" ");
			Результат.Добавить(НРег(Сред(Наименование_ВР, НомерСимвола, 1)));
			
		Иначе
			
			Результат.Добавить(Сред(Наименование, НомерСимвола, 1));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, "");
	
КонецФункции

// Удаляет пустые значения из массива.
// 
// Параметры:
//  Массив - Массив.
//
Процедура УдалитьПустыеЗначения(Массив) Экспорт
	
	КоличествоЭлементов = Массив.Количество();
	Для Индекс = 1 По КоличествоЭлементов Цикл
		
		ОбратныйИндекс = КоличествоЭлементов - Индекс;
		ЭлементМассива = Массив[ОбратныйИндекс];
		Если ЗначениеЗаполнено(ЭлементМассива) Тогда
			Продолжить;
		КонецЕсли;
		
		Массив.Удалить(ОбратныйИндекс);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НайтиСтрокиВеткиДереваПоОтбору(Ветка, СтруктураОтбора, ТолькоПерваяСтрока)
	
	Результат = Новый Массив;
	
	СтрокиКОбработке = Новый Массив;
	Для Каждого Строка Из Ветка.ПолучитьЭлементы() Цикл
		СтрокиКОбработке.Добавить(Строка);
	КонецЦикла;
	
	Пока СтрокиКОбработке.Количество() > 0 Цикл
		
		ТекущаяСтрока = СтрокиКОбработке[0];
		СтрокиКОбработке.Удалить(0);
		
		ЕстьОтличия = Ложь;
		Для Каждого КлючИЗначение Из СтруктураОтбора Цикл
			Если ТекущаяСтрока[КлючИЗначение.Ключ] <> КлючИЗначение.Значение Тогда
				ЕстьОтличия = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Не ЕстьОтличия Тогда
			Результат.Добавить(ТекущаяСтрока);
			Если ТолькоПерваяСтрока Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого Строка Из ТекущаяСтрока.ПолучитьЭлементы() Цикл
			СтрокиКОбработке.Добавить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
